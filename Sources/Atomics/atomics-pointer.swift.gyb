//
//  atomics-pointer.swift
//  Atomics
//
//  Created by Guillaume Lessard on 2015-05-21.
//  Copyright Â© 2015-2017 Guillaume Lessard. All rights reserved.
//  This file is distributed under the BSD 3-clause license. See LICENSE for details.
//

@_exported import enum CAtomics.MemoryOrder
@_exported import enum CAtomics.LoadMemoryOrder
@_exported import enum CAtomics.StoreMemoryOrder
@_exported import enum CAtomics.CASType
% for Nullable in ['', 'NonNull']:
% for Mutable in ['', 'Mutable']:
% pointer = 'Pointer<Pointee>?' if (Nullable == '') else 'Pointer<Pointee>'
% optchain = '?' if (Nullable == '') else ''

public struct Atomic${Nullable}${Mutable}Pointer<Pointee>
{
#if swift(>=4.2)
  @usableFromInline var ptr = Atomic${Nullable}${Mutable}RawPointer()
#else
  @_versioned var ptr = Atomic${Nullable}${Mutable}RawPointer()
#endif

% if Nullable == '':
  public init() { }

% end
  public init(_ pointer: Unsafe${Mutable}${pointer})
  {
    self.initialize(pointer)
  }

  public mutating func initialize(_ pointer: Unsafe${Mutable}${pointer})
  {
    ptr.initialize(Unsafe${Mutable}RawPointer(pointer))
  }

#if swift(>=4.2)
  public var pointer: Unsafe${Mutable}${pointer} {
    @inlinable
    mutating get {
      return Unsafe${Mutable}Pointer<Pointee>(ptr.load(.relaxed)${optchain}.assumingMemoryBound(to: Pointee.self))
    }
  }
#else
  public var pointer: Unsafe${Mutable}${pointer} {
    @inline(__always)
    mutating get {
      return Unsafe${Mutable}Pointer<Pointee>(ptr.load(.relaxed)${optchain}.assumingMemoryBound(to: Pointee.self))
    }
  }
#endif

#if swift(>=4.2)
  @inlinable
  public mutating func load(order: LoadMemoryOrder = .sequential) -> Unsafe${Mutable}${pointer}
  {
    return Unsafe${Mutable}Pointer<Pointee>(ptr.load(order)${optchain}.assumingMemoryBound(to: Pointee.self))
  }
#else
  @inline(__always)
  public mutating func load(order: LoadMemoryOrder = .sequential) -> Unsafe${Mutable}${pointer}
  {
    return Unsafe${Mutable}Pointer<Pointee>(ptr.load(order)${optchain}.assumingMemoryBound(to: Pointee.self))
  }
#endif

#if swift(>=4.2)
  @inlinable
  public mutating func store(_ pointer: Unsafe${Mutable}${pointer}, order: StoreMemoryOrder = .sequential)
  {
    ptr.store(Unsafe${Mutable}RawPointer(pointer), order)
  }
#else
  @inline(__always)
  public mutating func store(_ pointer: Unsafe${Mutable}${pointer}, order: StoreMemoryOrder = .sequential)
  {
    ptr.store(Unsafe${Mutable}RawPointer(pointer), order)
  }
#endif

#if swift(>=4.2)
  @inlinable
  public mutating func swap(_ pointer: Unsafe${Mutable}${pointer}, order: MemoryOrder = .sequential) -> Unsafe${Mutable}${pointer}
  {
    return Unsafe${Mutable}Pointer<Pointee>(ptr.swap(Unsafe${Mutable}RawPointer(pointer), order)${optchain}.assumingMemoryBound(to: Pointee.self))
  }
#else
  @inline(__always)
  public mutating func swap(_ pointer: Unsafe${Mutable}${pointer}, order: MemoryOrder = .sequential) -> Unsafe${Mutable}${pointer}
  {
    return Unsafe${Mutable}Pointer<Pointee>(ptr.swap(Unsafe${Mutable}RawPointer(pointer), order)${optchain}.assumingMemoryBound(to: Pointee.self))
  }
#endif

#if swift(>=4.2)
  @inlinable
  public mutating func loadCAS(current: UnsafeMutablePointer<Unsafe${Mutable}${pointer}>,
                               future: Unsafe${Mutable}${pointer},
                               type: CASType = .weak,
                               orderSwap: MemoryOrder = .sequential,
                               orderLoad: LoadMemoryOrder = .sequential) -> Bool
  {
    return current.withMemoryRebound(to: (Unsafe${Mutable}RawPointer${optchain}).self, capacity: 1) {
      ptr.loadCAS($0, Unsafe${Mutable}RawPointer(future), type, orderSwap, orderLoad)
    }
  }
#else
  @inline(__always) @discardableResult
  public mutating func loadCAS(current: UnsafeMutablePointer<Unsafe${Mutable}${pointer}>,
                               future: Unsafe${Mutable}${pointer},
                               type: CASType = .weak,
                               orderSwap: MemoryOrder = .sequential,
                               orderLoad: LoadMemoryOrder = .sequential) -> Bool
  {
    return current.withMemoryRebound(to: (Unsafe${Mutable}RawPointer${optchain}).self, capacity: 1) {
      ptr.loadCAS($0, Unsafe${Mutable}RawPointer(future), type, orderSwap, orderLoad)
    }
  }
#endif

#if swift(>=4.2)
  @inlinable
  public mutating func CAS(current: Unsafe${Mutable}${pointer}, future: Unsafe${Mutable}${pointer},
                           type: CASType = .strong,
                           order: MemoryOrder = .sequential) -> Bool
  {
    return ptr.CAS(current, future, type, order)
  }
#else
  @inline(__always) @discardableResult
  public mutating func CAS(current: Unsafe${Mutable}${pointer}, future: Unsafe${Mutable}${pointer},
                           type: CASType = .strong,
                           order: MemoryOrder = .sequential) -> Bool
  {
    return ptr.CAS(current, future, type, order)
  }
#endif
}
% end
% end
% for (AtomicType, PointerType) in [('AtomicRawPointer', 'UnsafeRawPointer?'), ('AtomicNonNullRawPointer', 'UnsafeRawPointer'), ('AtomicMutableRawPointer', 'UnsafeMutableRawPointer?'), ('AtomicNonNullMutableRawPointer', 'UnsafeMutableRawPointer'), ('AtomicOpaquePointer', 'OpaquePointer?'), ('AtomicNonNullOpaquePointer', 'OpaquePointer')]:

@_exported import struct CAtomics.${AtomicType}

extension ${AtomicType}
{
  @available(*, unavailable, message: "If needed, use initialize(_ pointer: ${PointerType}) after the default initializer, as long as the instance is unshared")
  public init(_ pointer: ${PointerType})
  {
    self.init()
  }

#if swift(>=4.2)
  public var pointer: ${PointerType} {
    @inlinable
    mutating get {
      return load(.relaxed)
    }
  }
#else
  public var pointer: ${PointerType} {
    @inline(__always)
    mutating get {
      return load(.relaxed)
    }
  }
#endif

#if swift(>=4.2)
  @inlinable
  public mutating func load(order: LoadMemoryOrder = .sequential) -> ${PointerType}
  {
    return load(order)
  }
#else
  @inline(__always)
  public mutating func load(order: LoadMemoryOrder = .sequential) -> ${PointerType}
  {
    return load(order)
  }
#endif

#if swift(>=4.2)
  @inlinable
  public mutating func store(_ pointer: ${PointerType}, order: StoreMemoryOrder = .sequential)
  {
    store(pointer, order)
  }
#else
  @inline(__always)
  public mutating func store(_ pointer: ${PointerType}, order: StoreMemoryOrder = .sequential)
  {
    store(pointer, order)
  }
#endif

#if swift(>=4.2)
  @inlinable
  public mutating func swap(_ pointer: ${PointerType}, order: MemoryOrder = .sequential) -> ${PointerType}
  {
    return swap(pointer, order)
  }
#else
  @inline(__always)
  public mutating func swap(_ pointer: ${PointerType}, order: MemoryOrder = .sequential) -> ${PointerType}
  {
    return swap(pointer, order)
  }
#endif

#if swift(>=4.2)
  @inlinable @discardableResult
  public mutating func loadCAS(current: UnsafeMutablePointer<${PointerType}>,
                               future: ${PointerType},
                               type: CASType = .weak,
                               orderSwap: MemoryOrder = .sequential,
                               orderLoad: LoadMemoryOrder = .sequential) -> Bool
  {
    return loadCAS(current, future, type, orderSwap, orderLoad)
  }
#else
  @inline(__always) @discardableResult
  public mutating func loadCAS(current: UnsafeMutablePointer<${PointerType}>,
                               future: ${PointerType},
                               type: CASType = .weak,
                               orderSwap: MemoryOrder = .sequential,
                               orderLoad: LoadMemoryOrder = .sequential) -> Bool
  {
    return loadCAS(current, future, type, orderSwap, orderLoad)
  }
#endif

#if swift(>=4.2)
  @inlinable @discardableResult
  public mutating func CAS(current: ${PointerType}, future: ${PointerType},
                           type: CASType = .strong,
                           order: MemoryOrder = .sequential) -> Bool
  {
    return CAS(current, future, type, order)
  }
#else
  @inline(__always) @discardableResult
  public mutating func CAS(current: ${PointerType}, future: ${PointerType},
                           type: CASType = .strong,
                           order: MemoryOrder = .sequential) -> Bool
  {
    return CAS(current, future, type, order)
  }
#endif
}
% end
