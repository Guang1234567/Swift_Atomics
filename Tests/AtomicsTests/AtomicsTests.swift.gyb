//
//  AtomicsTests.swift
//  AtomicsTests
//
//  Copyright Â© 2015-2018 Guillaume Lessard. All rights reserved.
//  This file is distributed under the BSD 3-clause license. See LICENSE for details.
//

import XCTest

import Atomics

public class AtomicsBasicTests: XCTestCase
{
% for i in ['Int', 'UInt', 'Int8', 'UInt8', 'Int16', 'UInt16', 'Int32', 'UInt32', 'Int64', 'UInt64']:
  public func test${i}()
  {
    var i = Atomic${i}(0)
    XCTAssert(i.value == 0)
    i.initialize(1)
    XCTAssert(i.value == 1)

#if swift(>=4.0)
    let r1 = ${i}.randomPositive()
    let r2 = ${i}.randomPositive()
    let r3 = ${i}.randomPositive()
#else
% truncating = '' if (i == 'Int' or i == 'UInt' or i == 'Int64' or i == 'UInt64') else 'truncatingBitPattern: '
    let r1 = ${i}(${truncating}UInt.randomPositive())
    let r2 = ${i}(${truncating}UInt.randomPositive())
    let r3 = ${i}(${truncating}UInt.randomPositive())
#endif

    i.store(r1)
    XCTAssert(r1 == i.load())

    var j = i.swap(r2)
    XCTAssertEqual(r1, j)
    XCTAssertEqual(r2, i.load())

    j = i.add(r1)
    XCTAssertEqual(r2, j)
    XCTAssertEqual(r1 &+ r2, i.load())

    j = i.subtract(r2)
    XCTAssertEqual(r1 &+ r2, j)
    XCTAssertEqual(r1, i.load())

    j = i.increment()
    XCTAssertEqual(r1, j)
    XCTAssertEqual(r1 &+ 1, i.load())

    i.store(r3)
    j = i.decrement()
    XCTAssertEqual(r3, j)
    XCTAssertEqual(r3 &- 1, i.load())

    i.store(r1)
    j = i.bitwiseOr(r2)
    XCTAssertEqual(r1, j)
    XCTAssertEqual(r1 | r2, i.load())

    i.store(r2)
    j = i.bitwiseXor(r1)
    XCTAssertEqual(r2, j)
    XCTAssertEqual(r1 ^ r2, i.load())

    i.store(r1)
    j = i.bitwiseAnd(r2)
    XCTAssertEqual(r1, j)
    XCTAssertEqual(r1 & r2, i.load())

    i.store(r1)
    XCTAssertTrue(i.CAS(current: r1, future: r2, type: .strong))
    XCTAssertEqual(r2, i.load())

    j = r2
    i.store(r1)
    while(!i.loadCAS(current: &j, future: r3)) {}
    XCTAssertEqual(r1, j)
    XCTAssertEqual(r3, i.load())
  }

% end
% for p in ['Raw', 'MutableRaw', '', 'Mutable', 'Opaque']:
% for optional in ['Optional', '']:
% unsafe = 'Unsafe' if p != 'Opaque' else ''
% pointee = '<Int64>' if (p == '' or p == 'Mutable') else ''
  public func test${optional}${unsafe}${p}Pointer()
  {
% if optional == 'Optional':
    var n = Atomic${optional}${p}Pointer${pointee}()
    XCTAssertEqual(n.pointer, nil)

% end
% bang = '' if optional else '!'
    let r0 = ${unsafe}${p}Pointer${pointee}(bitPattern: UInt.randomPositive())${bang}
    let r1 = ${unsafe}${p}Pointer${pointee}(bitPattern: UInt.randomPositive())${bang}
    let r2 = ${unsafe}${p}Pointer${pointee}(bitPattern: UInt.randomPositive())${bang}
    let r3 = ${unsafe}${p}Pointer${pointee}(bitPattern: UInt.randomPositive())${bang}

    var i = Atomic${optional}${p}Pointer${pointee}(r0)
    XCTAssertEqual(i.pointer, r0)

    i.initialize(r1)
    XCTAssertEqual(i.pointer, r1)

    i.store(r0)
    XCTAssertEqual(r0, i.load())

    var j = i.swap(r2)
    XCTAssertEqual(r0, j)
    XCTAssertEqual(r2, i.load())

    i.store(r1)
    XCTAssertTrue(i.CAS(current: r1, future: r2, type: .strong))
    XCTAssertEqual(r2, i.load())

    j = r2
    i.store(r1)
    while(!i.loadCAS(current: &j, future: r3)) {}
    XCTAssertEqual(r1, j)
    XCTAssertEqual(r3, i.load())
  }

% end
% end
% for p in ['Raw', 'MutableRaw']:
% for optional in ['', 'Optional']:
  public func testAtomicTagged${optional}${p}Pointer()
  {
% bang = '' if optional else '!'
    let r0 = (Unsafe${p}Pointer(bitPattern: UInt.randomPositive())${bang}, 0)
    let r1 = (Unsafe${p}Pointer(bitPattern: UInt.randomPositive())${bang}, 1)
    let r2 = (Unsafe${p}Pointer(bitPattern: UInt.randomPositive())${bang}, 2)
    let r3 = (r2.0, r2.1+1)

    var p = AtomicTagged${optional}${p}Pointer(r3)
    XCTAssertEqual(r3.0, p.pointer)
    XCTAssertEqual(r3.1, p.tag)

    p.initialize((r3.0, r0.1))
    XCTAssertEqual(r3.0, p.pointer)
    XCTAssertEqual(r0.1, p.tag)

    p.store(r1, order: .release)
    XCTAssertEqual(r1.0, p.pointer)
    XCTAssertEqual(r1.1, p.tag)

    var j = p.swap(r2, order: .acqrel)
    XCTAssertEqual(r1.0, j.0)
    XCTAssertEqual(r1.1, j.1)
    j = p.load(order: .acquire)
    XCTAssertEqual(r2.0, j.0)
    XCTAssertEqual(r2.1, j.1)

    XCTAssertTrue(p.CAS(current: r2, future: r3, type: .strong, order: .relaxed))
    XCTAssertEqual(r3.0, p.pointer)
    XCTAssertEqual(r3.1, p.tag)

    XCTAssertFalse(p.CAS(current: j, future: r2, type: .weak, order: .relaxed))
    XCTAssertTrue(p.CAS(current: r3, future: r2, type: .strong, order: .relaxed))
    j = p.load(order: .relaxed)
    XCTAssertTrue(p.CAS(current: r2, future: r1, type: .strong, order: .relaxed))
    while !p.loadCAS(current: &j, future: r3, type: .weak, orderSwap: .relaxed, orderLoad: .relaxed) {}
    XCTAssertEqual(r1.0, j.0)
    XCTAssertEqual(r1.1, j.1)
    XCTAssertEqual(r3.0, p.pointer)
    XCTAssertEqual(r3.1, p.tag)
  }

% end
% end
  public func testBool()
  {
    var boolean = AtomicBool()
    boolean.initialize(false)
    XCTAssert(boolean.value == false)

    boolean.store(false)
    XCTAssert(boolean.value == false)

    boolean.store(true)
    XCTAssert(boolean.value == true)
    XCTAssert(boolean.value == boolean.load())

    boolean.store(true)
    boolean.or(true)
    XCTAssert(boolean.value == true)
    boolean.or(false)
    XCTAssert(boolean.value == true)
    boolean.store(false)
    boolean.or(false)
    XCTAssert(boolean.value == false)
    boolean.or(true)
    XCTAssert(boolean.value == true)

    boolean.and(false)
    XCTAssert(boolean.value == false)
    boolean.and(true)
    XCTAssert(boolean.value == false)

    boolean.xor(false)
    XCTAssert(boolean.value == false)
    boolean.xor(true)
    XCTAssert(boolean.value == true)

    var old = boolean.swap(false)
    XCTAssert(old == true)
    XCTAssert(boolean.swap(true) == false)

    boolean.CAS(current: true, future: false)
    if boolean.CAS(current: false, future: true, type: .strong)
    {
      XCTAssert(boolean.CAS(current: true, future: false, type: .strong))
      XCTAssert(boolean.loadCAS(current: &old, future: false, type: .strong) == false)
      XCTAssert(boolean.CAS(current: old, future: true, type: .strong))
    }
  }

  public func testFence()
  {
    threadFence()
    threadFence(order: .sequential)
  }
}
